# MySQL

## MySQL 특징

## 정규화
 - 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화(Normalization)라고 한다.

### 정규화 특징
1. 중복을 제거하고 한 곳에서 관리
2. 데이터 정합성 유지가 쉬움
3. 읽기시 참조 발생

### 반(비)정구화 특징
1. 중복을 허용
2. 데이터 정합성 유지가 어려움
3. 참조없이 읽기 가능

### 중복된 데이터면 반드시 정규화 필요?
 > 정규화도 비용
 > 읽기 비용을 지불하고, 쓰기 비용을 줄이는 것
 
### 정규화 시 고려해야 하는 사항
1. 얼마나 빠르게 데이터의 최신성을 보장해야 하는가?
2. 히스토리성 데이터는 정규화 하지 않아야 한다.
3. 데이터 변경 주기와 조회 주기는 어떻게 되는가?
4. 객체(테이블) 탐색 깊이가 얼마나 깊은가?

### 데이터베이스 성능 핵심
 - 메모리 속도/빠름 - 영속성/전원 공급되지 않으면 휘발 - 가격/비쌈
 - 디스크 속도/느림 - 영속성/영속성 있음 - 가격/저렴
 - 데이터베이스는 디스크에 저장됨
 - 메모리에 올라온 데이터로 최대한 요청을 처리 -> 메모리 캐시 히트율 높인다.
 - 메모리에 데이터 유실을 고려하여 WAL(Write Ahead Log) 사용
 - **디스크의 랜덤 I/O(접근)을 최소화**

### Index(인덱스)
 - **인덱스의 핵심은 탐색(검색) 범위를 최소화 하는 것**

#### 검색이 빠른 자료구조

##### HashMap
 - 단건 검색속도 O(1)
 - 범위 탐색속도 O(N)
 - 전방 일치 탐색 불가 ex) like 'AB%'

##### List
 - 정렬되지 않은 리스트의 탐색 O(N)
 - 정렬된 리스트의 탐색 O(logN)
 - 정렬되지 않은 리스트의 정렬 시간 복잡도 O(N) ~ O(N * logN)
 - 삽입 / 삭제 비용이 매우 높음

##### Tree
 - 트리 높이에 따라 시간 복잡도가 결정
 - 트리의 높이를 최소화하는 것이 중요!!!
 - 한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용 ex) Red-Black Tree, B+Tree

##### B+Tree
 - 삽입 / 삭제 시 항상 균형을 이룸
 - 하나의 노드가 여러 개의 자식 노드를 가질 수 있음
 - 리프노드에만 데이터 존재
 - 연속적인 데이터 접근 시 유리

#### 인덱스 다룰 때 주의할 점
 - 의도대로 인덱스가 동작 하지 않을 수 있음. explain으로 확인 필요
 - 인덱스도 비용! 쓰기를 희생하고 조회를 유리하게 하는 것 [정규화와 반대]


















