## - 목차 (ctrl + click)

1. [C++ 학습에 앞서](#1장.-C++-학습에-앞서)
2. [C언어 빠르게 훑기](#2장.-C언어-빠르게-훑기)
3. [C++ 들어가기](#3장.-C++-들어가기)
4. [C++ 자료형](#4장.-C++-자료형)







---

## 1장. C++ 학습에 앞서

#### 1-1. C++은 C의 기본 문법을 따른다.

* C언어를 굳이 배우지 않은 상태에서 C++을 배울 수 있지만 C의 기초적인 문법을 그대로 사용하고 있기 때문에 C의 기본 문법을 먼저 학습하는 것을 추천한다.
* C++이 C의 확장버전이라고 생각하는 사람이 많지만, 이제 두 언어는 절대 같은 언어가 아니다.
* 3년마다 새로운 표준안이 공개되고 또 컴파일러들에게 반영이 되고 있다. 이전 버전과 호환이 괜찮아서 새로운 버전이 공개되도 기존의 코드들을 대부분 사용할 수 있다.(장단점 존재)
* C++ 역사

```
C++ 은 역사가 매우 긴 언어다. 1979년에 컴퓨터 과학자인 Bjarne Stroustrup 이 C 언어에 클래스 라는 개념을 적립한 C with Classes 라는 언어가 C++ 의 전신인데, 1982년에 해당 언어를 조금 발전 시켜서 C++ 이라는 이름을 붙였다. 그리고 1998년에 C++ 의 첫 번째 표준이 공개되었는데 이를 C++ 98 이라고 부른다. 2003년에 표준안에 작은 몇 가지 개정이 있었지만 언어 자체는 크게 바뀌지 않았다.
그 동안 언어가 정체 상태에 있다가 비로소 2011년이 되서야 흔히 말하는 대격변 패치를 받고 여러가지 새로운 개념들이 추가되었다. 이 버전의 C++ 을 C++ 11 이라고 하는데, 참고로 C++ 11 부터 Modern C++ 이라고 부릅니다.
```





---

## 2장. C언어 빠르게 훑기

#### 2-1. 컴파일러란?

```
컴파일러란 영어로 Compiler라고 쓴다. 말 그대로 컴파일(compile)을 해주는 것(-r)이다.
그러면 컴파일은 뭘까? 컴퓨터는 0과 1밖에 모르는 바보다. 컴퓨터의 두뇌인 CPU에서는 수 많은 0과 1들이 돌아다니며 일처리를 하고 있다. 이런 바보에게 명령을 내리는 법도 0과 1로 이뤄져야 할 것이다. 010011101 이런식으로 말이다. 실제로 옛날에는 비슷한 방법으로 명령을 내렸지만 훌륭한 사람들이 사람이 알아들을 수 있는 '언어'로 프로그래밍을 할 수 있게 했다.
예를 들어서 1+1을 하기 위한 명령을 컴퓨터에게 내린다면

01011101010101 이 되겠지만 컴퓨터 언어를 통해 간단하게

1 + 1 로 표현할 수 있게 됐단 말이다.

문제는 컴퓨터는 인간의 언어를 알아볼 수 없기 때문에 컴퓨터가 이해할 수 있도록 0과 1로 바꿔주는 녀석이 필요하다는 거다. 이렇게 사람들이 사용하는 '프로그래밍 언어'와 컴퓨터가 이해하는 '기계어' 사이 다리 역할을 수행하는 것이 바로 컴파일러 되겠다.
```

*** 사용할 컴파일러는 Visual Studio를 사용**

#### 2-1. Hello world 분석

```c++
#include <stdio.h>
int main() {
    printf("Hello, World! \n");
    return 0;
}
```

```c++
#include <stdio.h>  
#include는 괄호 안에 있는 파일을 우리 프로그램으로 불러온다는 의미다.
말 그대로, 해당 파일의 내용이 컴파일 할 때 우리 파일에 그대로 복사된다. 위 코드의 경우 stdio.h라는 파일을 포함시켰다. 왜 stdio.h 라는 파일을 포함시켰을까?
    
int main()
위 문장은 main 이라는 함수를 정의한 것으로, main은 모든 c 프로그램이 처음으로 시작되는 부분이다. 이전에 프로그램을 실행한다는 말의 의미가 cpu의 명령어 레지스터에 프로그램의 시작 명령어 주소값을 전달한다고 했는데, 실제 main의 첫 번째 명령어의 주소값이 전달 된다고 생각하면 된다.
main 옆에 int는 integer로 정수값을 반환한다는 뜻이다.
    
printf("Hello, World! \n");
위 문장은 괄호안에 내용을 화면에 출력할 수 있게 해주는 함수다.
화면에 문자를 출력한다는 것은 매우 복잡한 과정이다. 운영체제에 글자를 뿌려야 한다는 메시지를 보내고, 운영체제는 하드웨어(모니터)에 출력한다는 것을 다시 전달해줘야 한다.
위 모든 과정을 하나하나 작성하기는 상당히 피곤한 일로, 위 모든 내용을 포함하고 있는 파일이 필요한데, 그것이 바로 stdio.h다.
stdio는 STanDard Input Output의 약자로 표준 입출력을 뜻한다. 이 파일에는 입력과 출력, 즉 화면에 출력하고 (혹은 파일에 데이터를 쓰고), 입력을 받아들이는 것(혹은 파일을 읽는것)을 수행할 수 있는 기능들을 제공한다. 
C에서는 .h로 끝나는 파일을 헤더 파일이라 부른다.(헤더파일은 나중에 재설명)

\n은 개행문자로 키보드 상의 엔터를 뜻합니다.

마지막으로 중요한 것은 모든 문장이 끝나는 부분에 세미콜론(;)을 찍어주어야 한다는 것이다.
    
return 0;
0을 반환한다는 뜻으로 함수가 int main을 반환한다고 정의하였는데, 실제로 정수값인 0을 반환하는 것이다. 그럼 왜? 누구한테? 0을 반환하는 것일까? 이 프로그램을 실행하는 프로그램한테 반환을 하게되는데 왜 0을 반환할까? 0을 반환한다는 것은 컴퓨터에게 프로그램이 무사히 종료되었음을 알리는 것이다. 1을 반환하면 반대로 오류가 발생했다는 것을 알리는 것이다.

```

#### 2-2. 조건문

```c++
#include <stdio.h>
int main() {
    double i, j;
    printf("나누고 싶은 두 정수를 입력하세요 : ");
    scanf("%lf %lf", %i, %j);
    
    if (j == 0) {
        printf("0으로 나눌 수 없습니다. \n");
        return 0;
    } else {
    	printf("%f 를 %f 로 나눈 결과는 : %f \n", i, j, i / j);
	    return 0 
    }
}
```

#### 2-3. 반복문

```c++
/* 구구단 for문*/
#include <stdio.h>
int main() {
  int i, j;

  for (i = 1; i < 10; i++) {
    for (j = 1; j < 10; j++) {
      printf(" %d x %d = %d \n", i, j, i * j);
    }
  }
  return 0;
}

/* while 문 */
#include <stdio.h>
int main() {
  int i = 1, sum = 0;
  while (i <= 100) {
    sum += i;
    i++;
  }
  printf("1 부터 100 까지의 합 : %d \n", sum);
  return 0;
}

/* do-while문 */
#include <stdio.h>
int main() {
  int i = 1, sum = 0;
  do {
    sum += i;
    i++;
  } while (i < 1);

  printf(" sum : %d \n", sum);
  return 0;
}
```







## 3장. C++ 들어가기

- `객체` : 실존하는 것 → 메모리 공간을 차지하고 있는 것.

- ```plaintext
  변수: 객체를 담는 공간, 객체를 가리킴. 문자로 된 주소라고 생각하면 된다.
  - int x = 10
    - x라는 변수 이름이 가리키고 있는 메모리 공간에 123 (숫자 객체)값을 넣는다. 
  
  ```

   

- `L-value` : 주소를 갖고 있는 어떤 공간

- `R-value` : 공간에 넣을 어떤 값 !!

- 변수는 항상 초기화 하는 습관을 들이자 !

  - int x → 초기화 되기 전 -> 쓰레기 값이 들어가 있음.

  - ```plaintext
    초기화: 변수가 가리키는 공간을 할당 받자마자 값을 그 공간에 저장
    ```

    - ```plaintext
      Release 모드에서는 int x; 처럼 초기화를 안하면 0으로 초기화 해준다. 주의하기!
      
      - 0으로 초기화 되는게 개발자 의도가 아니였다면 큰일 날 수도 있다.
      ```
    
  - `대입` : 변수가 가리키는 공간에 값을 저장(덮어 씌움)

- printf

  - \#include <cstdio>, <stdio>
  - %d %f 등등

- cin, cout, endl

  - \#include <iostream>

  - `<<`,`>>` 을 오버로딩해서 객체 타입에 따라 다르게 입출력되게 할 수 있음

  - ```plaintext
    cout: 화면 콘솔 출력 cout<<
    ```

    - ex)

      ```
        int x = 1024;
        std::cout << "x is " << x << std::endl;
      ```

  - `cin` : 화면 콘솔 입력 cin `>>`

  - `endl` : 줄바꿈

- ```plaintext
  std::: cin, cout을 사용할 수 있는 네임스페이스
  
  - using namespace std; 를 앞에 써주면 `std::` 생략 가능
  ```

   

#### 함수

```C++
int add (int num_a, int num_b)
{
	int sum = num_a + num_b;
	return sum;
}
int main()
{
	cout << add(1, 2) << endl;
}
```

- 매개변수인 num_a, num_b 그리고 sum은 지역변수 로서 함수 실행이 끝남과 함께 사라진다.
- main 함수에서 add(1,2)를 호출

​	-> num_a = 1; num_b = 2;

​	-> sum = 3;

​	-> 3값이 들어있는 sum을 리턴하고 num_a, num_b, sum은 사라진다

- 함수는 return을 만나면 바로 종료
- 함수 안에서 또 함수 정의는 불가능 ( 파이썬은 가능 )



#### 변수명, 함수명 짓기

- 숫자시작 불가
- 특수문자 시작 불가 (_언더바는 가능)
- 예약어로 변수명 짓기 불가
- 빈칸 불가



#### 지역 범위

- {}중괄호 범위내에서 정의, 선언된 변수는 중괄호 범위를 벗어나면 메모리에서 사라진다.
- 같은 지역 범위 내에서 이미 있는 같은 이름 변수 선언하는 것은 허용하지 않는다.

```c++
가능
{
    int x = 1;
}
{ //여기서 기존 int x = 1은 사라진 상태
    int x = 2;
}

불가능
{
    int x = 1;
    int x = 2; // 불가능, 오류
}

x는 모두 동일 변수, 동일 주소
int x = 0;
{
    x = 1; // int x가 더 큰범위기 때문에 먼저 선언한 범위 밖의 x와 동일하다.
}
x = 2;
```



#### 선언과 정의의 분리

- 컴퓨터는 순서대로 앞부터 읽는다
- main안에서 쓰이는 함수의 정의가 main 뒤에 있으면 읽기 불가능

```c++
 int main()
  {
  	f(); // 정의가 뒤에 있어서 main 입장에선 이 함수가 어떤 함수인지 모름 
  }
  void f()
  {
  	std::cout << "love" << std::endl;
  }
```



#### 컴파일 과정

- 컴파일 역할
  - 문법 체크 + static 한 영역들 메모리 할당을 수행
  - 프로그램이 실행되기 전에 미리 메모리에 할당되어 있어야 하는 부분들, 런타임 때 메모리가 결정되는 부분들은 제외
- 헤더 파일은 컴파일되지 않는다
  - 헤더 파일은 include한 cpp 파일 내에 전체 복사될 뿐
- c++ 파일들은 각각 독립적으로 컴파일된다.
- 그 다음에 컴파일이 완료된 c++ 파일들을 링킹한다.



#### 헤더파일 생성

- 한 코드 파일에 모든 내용을 다 넣는건 추천하지 않는다.
  - #include "add.h" 해주면
    - add.h 헤더 파일에 정의해 놓은 함수와 변수들을 마음대로 사용 가능하다.
    - add.h 헤더 파일은 프로젝트와 동일한 위치에 존재해야 한다.
      - 다른 위치에 있다면 #include "myfolder/add.h" 이런식으로 상대 경로로 작성해야함
    - 단, add.cpp이 있다면 add.cpp도 같은 위치여야 한다.



## 4장. C++ 자료형

#### Character

- char는 정수이기도 하다. ASCII에 대응되어 저장되기 때문에.

  - char나 bool이나 내부적으로는 정수 Integer로 저장되고 보여질땐 변환

    ```
      char c = 65; // c를 출력하면 'A'출력
      bool b = true; // b를 출력하면 '1' 출력
    ```

- `char` : 최소 1byte 크기의 문자.

- `char16_t` : char보다 작지 않은 최소 2byte 크기의 문자. ex) 한글

- `char32_t` : char보다 작지 않은 최소 4byte 크기의 문자.

- `wchar_t` : 표현할 수 있는 최대 크기의 문자세트. 주로 유니코드 문자에 사용된다.

#### signed integer

- 음수, 0, 양수.

- unsigned integer와 저장되는 방식이 다르다.

- `signed char` : char와 같은 사이즈인 최소 1byte 크기의 정수.

- (signed)

  ```plaintext
  int: short 보다 작지 않은 최소 2byte 크기의 정수.
  ```

  - 대부분 4byte

- (signed) `long` (int) : int보다 작지 않은 최소 4byte 크기의 정수.

- (signed)

  ```plaintext
  (int) : long 보다 작지 않은 최소 8byte 크기의 정수.
  ```

  (int) : long 보다 작지 않은 최소 8byte 크기의 정수.

  - C99, C++11 부터 지원
